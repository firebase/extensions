#!/usr/bin/env node

/*
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import program = require("commander");
import firebase = require("firebase-admin");
import inquirer from "inquirer";

import { FirestoreBigQuerySchemaViewFactory, FirestoreSchema } from "./schema";
import { readSchemas } from "./schema-loader-utils";
import { runAgent } from "./schema/genkit";

const BIGQUERY_VALID_CHARACTERS = /^[a-zA-Z0-9_]+$/;
const FIRESTORE_VALID_CHARACTERS = /^[^\/]+$/;
const GCP_PROJECT_VALID_CHARACTERS = /^[a-z][a-z0-9-]{0,29}$/;
const DEFAULT_SAMPLE_SIZE = 100;

const validateInput = (value: any, name: string, regex: RegExp) => {
  if (!value || value === "" || value.trim() === "") {
    return `Please supply a ${name}`;
  }
  if (!value.match(regex)) {
    return `The ${name} must only contain letters or spaces`;
  }
  return true;
};

function collect(value, previous) {
  return previous.concat([value]);
}

export async function sampleFirestoreDocuments(
  collectionPath: string,
  sampleSize: number
): Promise<any[]> {
  const db = firebase.firestore();

  try {
    const snapshot = await db
      .collection(collectionPath)
      .where("__name__", ">=", Math.random().toString())
      .limit(sampleSize)
      .get();

    const documents = snapshot.docs.map((doc) => {
      const data = doc.data();
      return serializeDocument(data);
    });

    console.log(`Successfully sampled ${documents.length} documents.`);
    return documents;
  } catch (error) {
    console.error("Error sampling documents:", error);
    throw error;
  }
}

function serializeDocument(data: any): any {
  if (!data) return null;

  if (data instanceof Date) {
    return { _type: "timestamp", value: data.toISOString() };
  }

  if (data instanceof firebase.firestore.GeoPoint) {
    return {
      _type: "geopoint",
      latitude: data.latitude,
      longitude: data.longitude,
    };
  }

  if (data instanceof firebase.firestore.DocumentReference) {
    return { _type: "reference", path: data.path };
  }

  if (Array.isArray(data)) {
    return data.map((item) => serializeDocument(item));
  }

  if (typeof data === "object") {
    const result = {};
    for (const [key, value] of Object.entries(data)) {
      result[key] = serializeDocument(value);
    }
    return result;
  }

  return data;
}

const packageJson = require("../package.json");

program
  .name("gen-schema-views")
  .description(packageJson.description)
  .version(packageJson.version)
  .option(
    "--non-interactive",
    "Parse all input from command line flags instead of prompting the caller.",
    false
  )
  .option(
    "-P, --project <project>",
    "Firebase Project ID for project containing Cloud Firestore database."
  )
  .option(
    "-B, --big-query-project <big-query-project>",
    "Google Cloud Project ID for BigQuery (can be the same as the Firebase project ID)."
  )
  .option(
    "-d, --dataset <dataset>",
    "The ID of the BigQuery dataset containing a raw Cloud Firestore document changelog."
  )
  .option(
    "-t, --table-name-prefix <table-name-prefix>",
    "A common prefix for the names of all views generated by this script."
  )
  .option(
    "-c, --collection-path <path>",
    "Firestore collection path for Gemini to analyze"
  )
  .option(
    "-f, --schema-files <schema-files>",
    "A collection of files from which to read schemas.",
    collect,
    []
  )
  .option(
    "--use-gemini",
    "Use Gemini to automatically analyze your data and generate a draft schema. You will have a chance to manually view and approve this schema before it is used.",
    false
  )
  .option(
    "--schema-dir <directory>",
    "Directory to store generated schemas",
    "./schemas"
  )
  .option("--google-ai-key <key>", "Google AI API Key for Gemini");

const questions = [
  {
    message: "What is your Firebase project ID?",
    name: "project",
    default: process.env.PROJECT_ID,
    type: "input",
    validate: (value) =>
      validateInput(value, "project ID", FIRESTORE_VALID_CHARACTERS),
  },
  {
    message:
      "What is your Google Cloud Project ID for BigQuery? (can be the same as the Firebase project ID)",
    name: "bigQueryProject",
    default: process.env.PROJECT_ID,
    type: "input",
    validate: (value) =>
      validateInput(value, "BigQuery project ID", GCP_PROJECT_VALID_CHARACTERS),
  },
  {
    message:
      "What is the ID of the BigQuery dataset the raw changelog lives in? (The dataset and the raw changelog must already exist!)",
    name: "dataset",
    type: "input",
    validate: (value) =>
      validateInput(value, "dataset ID", BIGQUERY_VALID_CHARACTERS),
  },
  {
    message:
      "What is the table name prefix for which you want to generate a schema view?",
    name: "tableNamePrefix",
    type: "input",
    validate: (value) =>
      validateInput(value, "table name prefix", BIGQUERY_VALID_CHARACTERS),
  },
  {
    message:
      "Would you like to use a Gemini to automatically analyze your data and generate a draft schema?",
    name: "useGemini",
    type: "confirm",
    default: false,
  },
  {
    message: "What is the Firestore collection path you want to analyze?",
    name: "collectionPath",
    type: "input",
    when: (answers) => answers.useGemini,
    validate: (value) =>
      validateInput(value, "collection path", FIRESTORE_VALID_CHARACTERS),
  },
  {
    message: "Please provide your Google AI API Key:",
    name: "googleAiKey",
    type: "password",
    when: (answers) => answers.useGemini,
    validate: (value) => {
      if (!value || value.trim() === "") {
        return "Google AI API Key is required";
      }
      return true;
    },
  },
  {
    message:
      "Where should this script look for schema definitions? (Enter a comma-separated list of, optionally globbed, paths to files or directories).",
    name: "schemaFiles",
    type: "input",
    when: (answers) => !answers.useGemini,
  },
  {
    message: "Where should the generated schema files be stored?",
    name: "schemaDirectory",
    type: "input",
    when: (answers) => answers.useGemini,
    default: "./schemas",
  },
];

interface CliConfig {
  projectId: string;
  bigQueryProjectId: string;
  datasetId: string;
  tableNamePrefix: string;
  collectionPath?: string;
  schemaDirectory?: string;
  schemas: { [schemaName: string]: FirestoreSchema };
  useGemini?: boolean;
  agentSampleSize?: number;
  googleAiKey?: string;
}

async function run(): Promise<number> {
  const config: CliConfig = await parseConfig();

  process.env.PROJECT_ID = config.projectId;
  process.env.GOOGLE_CLOUD_PROJECT = config.bigQueryProjectId;

  if (!firebase.apps.length) {
    firebase.initializeApp({
      credential: firebase.credential.applicationDefault(),
      databaseURL: `https://${config.projectId}.firebaseio.com`,
    });
  }

  const viewFactory = new FirestoreBigQuerySchemaViewFactory(
    config.bigQueryProjectId
  );

  if (config.useGemini) {
    try {
      const sampleData = await sampleFirestoreDocuments(
        config.collectionPath!,
        config.agentSampleSize!
      );
      const chat = runAgent(
        config.googleAiKey!,
        config.schemaDirectory || "./schemas",
        config.tableNamePrefix,
        config.collectionPath!,
        sampleData
      );
      await chat.send(
        `Please analyze these documents and generate an appropriate BigQuery schema. ` +
          `**Then use the writeSchema tool to save it as "${config.tableNamePrefix}.json**". ` +
          `Let me know once you've created the schema file.`
      );
      const schemaName = `${config.tableNamePrefix}`;
      const schemas = readSchemas([`./schemas/${schemaName}.json`]);

      if (!schemas[schemaName]) {
        console.error(
          `Error reading schema file: ./schemas/${schemaName}.json. Gemini may have failed to generate the schema.
          If the issue persists, please manually create the schema file and run the script again.`
        );
        process.exit(1);
      }

      const schemaPath = `./schemas/${config.tableNamePrefix}.json`;
      console.log(
        `\nSchema generation complete. The schema file has been created at: ${schemaPath}. Please review the schema file and confirm if you want to proceed.`
      );

      const confirmation = await inquirer.prompt([
        {
          type: "confirm",
          name: "proceed",
          message:
            "Have you reviewed the schema and want to proceed with creating the views?",
          default: false,
        },
      ]);

      if (!confirmation.proceed) {
        console.log(
          "Operation cancelled. Please modify the schema file and run the script again."
        );
        process.exit(0);
      }

      for (const name in schemas) {
        await viewFactory.initializeSchemaViewResources(
          config.datasetId,
          config.tableNamePrefix,
          name,
          schemas[name]
        );
      }

      console.log("Schema views created successfully.");
    } catch (error) {
      console.error("Error during schema generation:", error);
      throw error;
    }
  } else {
    if (Object.keys(config.schemas).length === 0) {
      console.log(`No schema files found!`);
    }

    for (const schemaName in config.schemas) {
      await viewFactory.initializeSchemaViewResources(
        config.datasetId,
        config.tableNamePrefix,
        schemaName,
        config.schemas[schemaName]
      );
    }
  }
  return 0;
}

async function parseConfig(): Promise<CliConfig> {
  program.parse(process.argv);
  if (program.nonInteractive) {
    if (
      !program.useGemini &&
      (program.project === undefined ||
        program.bigQueryProject === undefined ||
        program.dataset === undefined ||
        program.tableNamePrefix === undefined ||
        program.schemaFiles.length === 0)
    ) {
      program.outputHelp();
      process.exit(1);
    }

    if (program.useGemini) {
      if (!program.googleAiKey) {
        console.error(
          "Google AI API Key is required when using the Gemini Agent"
        );
        process.exit(1);
      }

      if (!program.collectionPath) {
        console.error(
          "Collection path is required when using the Gemini Agent"
        );
        process.exit(1);
      }
    }

    return {
      projectId: program.project,
      bigQueryProjectId: program.bigQueryProject,
      datasetId: program.dataset,
      tableNamePrefix: program.tableNamePrefix,
      collectionPath: program.collectionPath,
      schemas: program.useGemini ? {} : readSchemas(program.schemaFiles),
      useGemini: program.useGemini,
      agentSampleSize: DEFAULT_SAMPLE_SIZE,
      googleAiKey: program.googleAiKey,
    };
  }
  const answers = await inquirer.prompt(questions);

  return {
    projectId: answers.project,
    bigQueryProjectId: answers.bigQueryProject,
    datasetId: answers.dataset,
    tableNamePrefix: answers.tableNamePrefix,
    collectionPath: answers.collectionPath,
    schemas: answers.useGemini
      ? {}
      : readSchemas(
          answers.schemaFiles
            .split(",")
            .map((schemaFileName) => schemaFileName.trim())
        ),
    useGemini: answers.useGemini,
    agentSampleSize: DEFAULT_SAMPLE_SIZE,
    googleAiKey: answers.googleAiKey,
  };
}
if (process.env.NODE_ENV !== "test") {
  run()
    .then((result) => {
      console.log("done.");
      process.exit();
    })
    .catch((error) => {
      console.log(JSON.stringify(error));
      console.error(error.message);
      process.exit();
    });
}
